## Tasks
1. Try to totally change the core. 8 Blocks
  * Block 1: Compute all the Eachhw of core
  * Block 2:
  * Block 3:
  * Block 4:
  * Block 5:
  * Block 6:
  * Block 7:
  * Block 8:

### Core
#### Member
1. layer_id
2. h_out_
3. w_out_
4. H_out_
5. W_out_
6. outputspineid
7. v_tob_in_, v_pe_, v_mfb_, compute_finifshed_
8. current_spine_batches_
9. A reference to batches_per_hw_
10. 

```cpp
// All comments are in English.
#pragma once
#include <cstdint>
#include <vector>
#include <unordered_map>
#include <stdexcept>
#include <memory>
#include <iostream>

// ---- Minimal forward decls: replace with your real headers ----
// DRAM
namespace sf { namespace dram { class SimpleDRAM; } }

// OutputSpine (owned by Core)
class OutputSpine {
public:
  void SetSpineID(int spine_id);
};

// TiledOutputBuffer (owned by Core)
class TiledOutputBuffer {
public:
  void ClearAll();
};

// PEArray (owned by Core): must provide the per-tile init for PEs
class PEArray {
public:
  // Initialize per-PE output neuron IDs for a fresh tile
  void InitPEsOutputNIDBeforeLoop(int total_tiles,
                                  int tile_idx,
                                  int h, int w,
                                  int W);
};

// FilterBuffer (owned by Core): must provide weight load API
class FilterBuffer {
public:
  // Load weights of (tile_id) among (total_tiles) for (layer_id); return bytes loaded
  std::uint32_t LoadWeightFromDram(int total_tiles, int tile_id, int layer_id);
};

// InputSpineBuffer (owned by Core): must provide preload API
class InputSpineBuffer {
public:
  // Dispatch logical spine-ids to physical ISBs via DRAM and preload the first batch
  void PreloadFirstBatch(const std::vector<int>& logical_spine_ids, int layer_id);

  // Query if all physical ISBs are empty
  bool AllEmpty() const;
};

class Core {
public:
  explicit Core(sf::dram::SimpleDRAM* dram);

  // Per-layer static configuration
  void ConfigureForLayer(int layer_id,
                         int H_out, int W_out,
                         int Kh, int Kw,
                         int Sh, int Sw,
                         int Ph, int Pw);

  // Provide the precomputed batches table from ConvLayer
  void SetBatchesTable(const std::unordered_map<std::uint64_t,
                        std::vector<std::vector<int>>>* batches_per_hw);

  // Transfer ownership of OutputSpine / TOB into Core
  void SetOwnedOutputSpine(std::unique_ptr<OutputSpine> os) { output_spine_ = std::move(os); }
  void SetOwnedTOB(std::unique_ptr<TiledOutputBuffer> tob)  { tob_ = std::move(tob); }

  // (Optional) Install owned subsystems (for full integration)
  void SetOwnedPEArray(std::unique_ptr<PEArray> pea)        { pe_array_ = std::move(pea); }
  void SetOwnedFilterBuffer(std::unique_ptr<FilterBuffer> f){ fb_ = std::move(f); }
  void SetOwnedInputSpineBuffer(std::unique_ptr<InputSpineBuffer> i){ isb_ = std::move(i); }

  // ConvLayer should set total_tiles_ once per layer (ceil(C_out/kNumPE))
  void SetTotalTiles(int total_tiles) {
    if (total_tiles <= 0) throw std::invalid_argument("Core::SetTotalTiles: total_tiles must be > 0.");
    total_tiles_ = total_tiles;
  }

  // ===== Per-(h,w) preparation =====
  void PrepareForSpine(int h_out, int w_out);
  void Update_Eachhw(int h_out, int w_out);
  void UpdateOutputSpineID_Eachhw();
  void ClearTOB_Eachhw();
  void ResetSignal_Eachhw();
  void ComputeInputSpineBatches_Eachhw();

  // ===== Per-tile preparation (new) =====
  void PrepareForTile(int tile_id);
  void ComputePEArrayOutID_EachTile(int tile_id);
  void ResetSignal_EachTile();
  std::uint32_t LoadWeightFromDram_EachTile(int tile_id);
  void LoadInputSpine_EachTile();

  // Accessors
  int  layer_id() const { return layer_id_; }
  int  H_out()    const { return H_out_; }
  int  W_out()    const { return W_out_; }
  int  h_out()    const { return h_out_cur_; }
  int  w_out()    const { return w_out_cur_; }
  int  total_tiles() const { return total_tiles_; }

  const std::vector<std::vector<int>>& current_inputspine_batches() const {
    return current_inputspine_batches_;
  }

  static std::uint64_t PackHW(int h, int w) {
    return (static_cast<std::uint64_t>(static_cast<std::uint32_t>(h)) << 32) |
           static_cast<std::uint32_t>(w);
  }

private:
  // Stub for FIFO capacity check; replace with your real logic
  bool TargetFifoHasSpace_() const {
    // TODO: query actual FIFO(s)
    return true;
  }

private:
  // ---- Wiring ----
  sf::dram::SimpleDRAM* dram_ = nullptr;     // non-owning

  // ---- Per-layer static params ----
  int layer_id_ = 0;
  int H_out_ = 0, W_out_ = 0;
  int Kh_ = 0, Kw_ = 0;
  int Sh_ = 0, Sw_ = 0;
  int Ph_ = 0, Pw_ = 0;

  // ---- External tables (non-owning) ----
  const std::unordered_map<std::uint64_t, std::vector<std::vector<int>>>* batches_per_hw_ = nullptr;

  // ---- Owned subsystems ----
  std::unique_ptr<OutputSpine>       output_spine_;
  std::unique_ptr<TiledOutputBuffer> tob_;
  std::unique_ptr<PEArray>           pe_array_;
  std::unique_ptr<FilterBuffer>      fb_;
  std::unique_ptr<InputSpineBuffer>  isb_;

  // ---- Per-(h,w) state ----
  int h_out_cur_ = 0;
  int w_out_cur_ = 0;

  bool v_tob_in_         = false;
  bool v_pe_             = false;
  bool v_mfb_            = false;
  bool compute_finished_ = false;

  std::vector<std::vector<int>> current_inputspine_batches_;
  int batch_cursor_ = -1;

  // ---- Per-layer tiling ----
  int total_tiles_ = 0;
};

```


```cpp
// All comments are in English.
#include "core.hpp"

using sf::dram::SimpleDRAM;

Core::Core(SimpleDRAM* dram)
  : dram_(dram)
{
  if (!dram_) {
    throw std::invalid_argument("Core: dram pointer must not be null.");
  }
}

void Core::ConfigureForLayer(int layer_id,
                             int H_out, int W_out,
                             int Kh, int Kw,
                             int Sh, int Sw,
                             int Ph, int Pw)
{
  layer_id_ = layer_id;
  H_out_ = H_out;  W_out_ = W_out;
  Kh_ = Kh; Kw_ = Kw;
  Sh_ = Sh; Sw_ = Sw;
  Ph_ = Ph; Pw_ = Pw;

  if (H_out_ < 0 || W_out_ < 0) {
    throw std::invalid_argument("Core::ConfigureForLayer: invalid output dimensions.");
  }
}

void Core::SetBatchesTable(const std::unordered_map<std::uint64_t,
                             std::vector<std::vector<int>>>* batches_per_hw)
{
  batches_per_hw_ = batches_per_hw;
}

void Core::PrepareForSpine(int h_out, int w_out)
{
  Update_Eachhw(h_out, w_out);
  UpdateOutputSpineID_Eachhw();
  ClearTOB_Eachhw();
  ResetSignal_Eachhw();
  ComputeInputSpineBatches_Eachhw();
}

void Core::Update_Eachhw(int h_out, int w_out)
{
  if (h_out < 0 || h_out >= H_out_ || w_out < 0 || w_out >= W_out_) {
    throw std::out_of_range("Core::Update_Eachhw: (h_out, w_out) is out of range.");
  }
  h_out_cur_ = h_out;
  w_out_cur_ = w_out;
}

void Core::UpdateOutputSpineID_Eachhw()
{
  const int spine_id = h_out_cur_ * W_out_ + w_out_cur_;
  if (output_spine_) {
    output_spine_->SetSpineID(spine_id);
  } else {
    std::cout << "[Core] OutputSpine not set; spine_id=" << spine_id << "\n";
  }
}

void Core::ClearTOB_Eachhw()
{
  if (tob_) {
    tob_->ClearAll();
  } else {
    std::cout << "[Core] TOB not set; nothing to clear.\n";
  }
}

void Core::ResetSignal_Eachhw()
{
  v_tob_in_         = false;
  v_pe_             = false;
  v_mfb_            = false;
  compute_finished_ = false;
}

void Core::ComputeInputSpineBatches_Eachhw()
{
  current_inputspine_batches_.clear();
  batch_cursor_ = -1;

  if (!batches_per_hw_) {
    std::cout << "[Core] batches_per_hw_ not set; no input spine batches.\n";
    return;
  }

  const std::uint64_t key = PackHW(h_out_cur_, w_out_cur_);
  auto it = batches_per_hw_->find(key);
  if (it == batches_per_hw_->end()) {
    // No batches found for this site; keep empty.
    return;
  }
  current_inputspine_batches_ = it->second; // copy small vectors
}

// ==================== Per-tile sequence ====================

void Core::PrepareForTile(int tile_id)
{
  // Order: compute per-PE out IDs, reset per-tile signals, load weights, preload inputs.
  ComputePEArrayOutID_EachTile(tile_id);
  ResetSignal_EachTile();
  LoadWeightFromDram_EachTile(tile_id);
  LoadInputSpine_EachTile();
}

void Core::ComputePEArrayOutID_EachTile(int tile_id)
{
  if (total_tiles_ <= 0) {
    throw std::runtime_error("Core::ComputePEArrayOutID_EachTile: total_tiles_ not set.");
  }
  if (tile_id < 0 || tile_id >= total_tiles_) {
    throw std::out_of_range("Core::ComputePEArrayOutID_EachTile: tile_id out of range.");
  }
  if (W_out_ <= 0) {
    throw std::runtime_error("Core::ComputePEArrayOutID_EachTile: W_out_ not set.");
  }

  // Allow outer loop to enter StepOnce again and re-prime valids for a fresh tile
  compute_finished_ = false;

  if (!pe_array_) {
    std::cout << "[Core] PEArray not set; skipping PE output-id initialization.\n";
    return;
  }

  // Forward to PEArray helper; it should:
  // - compute per-PE out_id = base_pos + tile_offset + pe_idx
  // - register per-PE output id and threshold
  // - clear its internal out_spike entries for a fresh tile
  pe_array_->InitPEsOutputNIDBeforeLoop(/*total_tiles=*/ total_tiles_,
                                        /*tile_idx   =*/ tile_id,
                                        /*h         =*/ h_out_cur_,
                                        /*w         =*/ w_out_cur_,
                                        /*W         =*/ W_out_);
}

void Core::ResetSignal_EachTile()
{
  // Reference logic:
  // compute_finished_ = false;
  // v_tob_in_ = true;
  // v_pe_     = false;
  // v_mfb_    = (!isb_->AllEmpty()) && TargetFifoHasSpace();

  compute_finished_ = false;
  v_tob_in_ = true;
  v_pe_     = false;

  bool isb_has_data = false;
  if (isb_) {
    isb_has_data = !isb_->AllEmpty();
  } else {
    std::cout << "[Core] ISB not set; assuming empty.\n";
  }
  v_mfb_ = isb_has_data && TargetFifoHasSpace_();
}

std::uint32_t Core::LoadWeightFromDram_EachTile(int tile_id)
{
  if (!fb_) {
    std::cout << "[Core] FilterBuffer not set; cannot load weights.\n";
    return 0u;
  }
  if (total_tiles_ <= 0) {
    throw std::runtime_error("Core::LoadWeightFromDram_EachTile: total_tiles_ not set.");
  }
  if (tile_id < 0 || tile_id >= total_tiles_) {
    throw std::out_of_range("Core::LoadWeightFromDram_EachTile: tile_id out of range.");
  }

  // Delegate to FilterBuffer
  const std::uint32_t bytes = fb_->LoadWeightFromDram(total_tiles_, tile_id, layer_id_);
  return bytes;
}

void Core::LoadInputSpine_EachTile()
{
  if (!isb_) {
    std::cout << "[Core] ISB not set; cannot preload input spines.\n";
    return;
  }
  if (current_inputspine_batches_.empty()) {
    throw std::runtime_error("Core::LoadInputSpine_EachTile: no batches for current (h,w).");
  }

  // Dispatch logical ids to physical ISBs via DRAM (first batch)
  isb_->PreloadFirstBatch(current_inputspine_batches_[0], layer_id_);
  batch_cursor_ = 0;
}

```
#### Function
0. ConfigureCore:
   1. set the layer id
   2. set the H_out_, W_out_
   3. Configure all the components of its own.
   4. 
1. Update the h_out_, w_out_
2. UpdateWeightParameter(h_out, w_out)
3. UpdateOutputSpineID(layer_id, h_out, w_out, W_out)
4. ClearTOB()
5. ResetSignal() the v_tob_in_, v_pe_, v_mfb_, compute_finifshed_
6. ComputeSpineBatches by the reference of batches_per_hw_ and the h_out_, w_out_
7. 


for output spine:
    1. Update the h, w of the weight, use the wrapper to wrap the function: 
      void FilterBuffer::Update(int h_out, int w_out) {
        h_out_cur_ = h_out;
        w_out_cur_ = w_out;
      }
    2. UpdateOutputSpineID(layer_id, h_out, w_out, W_out) use the function set spineID from Output Spine
    3. 
